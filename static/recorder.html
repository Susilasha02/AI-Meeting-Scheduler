<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recorder — AI Meeting Scheduler</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --card: #fff;
      --accent: #6f46f6;
      --muted: #6b7280;
      --radius: 14px;
      --maxwidth: 1100px;
    }
    html,body { height:100%; margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial; background:var(--bg); color:#111; }
    .wrap { min-height:100%; display:flex; align-items:center; justify-content:center; padding:32px; box-sizing:border-box; }
    .card { width:100%; max-width:var(--maxwidth); background:var(--card); border-radius:var(--radius); padding:28px; box-shadow:0 6px 30px rgba(23,25,33,0.06); }
    .header { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
    .logo { width:56px; height:56px; border-radius:10px; background:linear-gradient(135deg,#6f46f6,#b794f4); display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:18px; }
    h1 { margin:0; font-size:20px; }
    p.lead { margin:6px 0 18px; color:var(--muted); font-size:14px; }
    .controls { display:flex; gap:12px; align-items:center; margin-bottom:18px; }
    button { padding:10px 16px; border-radius:10px; border:0; cursor:pointer; font-weight:600; }
    .btn-primary { background:var(--accent); color:white; }
    .btn-ghost { background:transparent; color:var(--accent); border:1px solid rgba(111,70,246,0.12); }
    .status { color:var(--muted); font-size:13px; }
    .wave { width:100%; height:86px; background:linear-gradient(180deg,#f8fafc,#fff); border-radius:10px; border:1px dashed #e6e9ef; display:flex; align-items:center; justify-content:center; color:#9aa3b2; margin-bottom:18px; }
    .transcript { max-height:260px; overflow:auto; padding:12px; background:#fafbff; border-radius:10px; border:1px solid #eef2ff; color:#111; font-size:14px; line-height:1.45; }
    .muted { color:var(--muted); font-size:13px; }
    .controls-right { margin-left:auto; color:var(--muted); font-size:13px; }
    .notice { color: #6b7280; font-size:13px; margin-top:10px; }
    .link { color:var(--accent); text-decoration:none; border-radius:8px; background:#f1eaff;padding:8px 10px;font-weight:600 }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="main">
      <div class="header">
        <div class="logo">TS</div>
        <div style="flex:1">
          <h1>Meeting Recorder</h1>
          <p class="lead">Automatically records meeting audio and generates transcript / MoM. Auto-starts when possible — click to give microphone permission if required.</p>
        </div>
        <div class="controls-right" id="uploadStatus">Idle</div>
      </div>

      <div class="controls">
        <button id="btnStart" class="btn-primary">Start Recording</button>
        <button id="btnStop" class="btn-ghost" disabled>Stop</button>
        <div class="status" id="status">Idle</div>
      </div>

      <div class="wave" id="wave">Mic status: waiting for input…</div>

      <div class="muted">Live Transcript</div>
      <div class="transcript" id="transcript">No transcript yet.</div>

      <div style="height:14px;"></div>
      <div class="muted">Upload / Save</div>
      <div style="margin-top:10px;display:flex;gap:10px;align-items:center;">
        <button id="uploadBtn" class="btn-ghost" disabled>Upload Audio & Transcript</button>
        <button id="openMomBtn" class="btn-ghost" style="display:none">Open MoM</button>
        <a id="momLink" href="#" target="_blank" style="display:none;margin-left:8px"></a>
      </div>
      <div class="notice" id="notice"></div>
    </div>
  </div>

<script>
/* Recorder + Transcription Script
   - Auto-attempts start on load
   - Uses audio constraints with echoCancellation/noiseSuppression/autoGainControl
   - Single MediaRecorder instance and single Web Speech Recognition
   - Simple dedupe logic to avoid repeated phrases, and joins recognized segments into a paragraph
*/
(async function(){
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('btnStart');
  const stopBtn = document.getElementById('btnStop');
  const wave = document.getElementById('wave');
  const transcriptEl = document.getElementById('transcript');
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadStatus = document.getElementById('uploadStatus');
  const notice = document.getElementById('notice');
  const openMomBtn = document.getElementById('openMomBtn');
  const momLinkEl = document.getElementById('momLink');

  let mediaStream = null;
  let recorder = null;
  let recordedChunks = [];
  let recognition = null;
  let liveTranscript = "";
  let lastRecognizedNormalized = ""; // for dedupe
  const APP_BASE = (window.APP_BASE_URL || '').replace(/\/$/,'') || location.origin;

  // audio constraints optimized for meetings
  const constraints = {
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      channelCount: 1,
      sampleRate: 44100
    }
  };

  function updateStatus(t){
    statusEl.textContent = t;
  }

  function showWave(msg){
    wave.textContent = msg;
  }

  function _normalize(s){
    return s.trim().toLowerCase().replace(/\s+/g,' ');
  }

  function appendTranscriptPiece(piece){
    if(!piece) return;
    const cleaned = piece.trim();
    if(!cleaned) return;
    const normalized = _normalize(cleaned);
    // dedupe identical repeats
    if(normalized === lastRecognizedNormalized) return;
    lastRecognizedNormalized = normalized;
    // join into paragraph (separate by a single space)
    if(!liveTranscript) {
      liveTranscript = cleaned;
      transcriptEl.textContent = cleaned;
    } else {
      // avoid double spaces
      liveTranscript = liveTranscript.trim() + " " + cleaned;
      transcriptEl.textContent = liveTranscript;
    }
  }

  // Start mic + media recorder
  async function startRecording(){
    updateStatus('Requesting microphone...');
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    }catch(err){
      updateStatus('Microphone permission required.');
      showWave('Click "Start Recording" to give mic permission.');
      throw err;
    }

    if(recorder){ recorder.stop(); recorder = null; }

    recordedChunks = [];
    recorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus' });
    recorder.ondataavailable = e => {
      if(e.data && e.data.size > 0) recordedChunks.push(e.data);
    };
    recorder.onstart = () => {
      updateStatus('Recording');
      startBtn.disabled = true;
      stopBtn.disabled = false;
      showWave('Recording… (audio is being captured)');
      uploadStatus.textContent = 'Recording';
    };
    recorder.onstop = () => {
      updateStatus('Stopped');
      startBtn.disabled = false;
      stopBtn.disabled = true;
      showWave('Recording stopped. Ready to upload.');
      uploadBtn.disabled = false;
      uploadStatus.textContent = 'Ready to upload';
    };

    recorder.start(1000); // collect chunks every 1s
    startSpeechRecognition();
  }

  function stopRecording(){
    if(recorder && recorder.state !== 'inactive') recorder.stop();
    if(mediaStream){
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
    stopSpeechRecognition();
  }

  // Web Speech API recognition with single instance
  function startSpeechRecognition(){
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SpeechRecognition) {
      appendTranscriptPiece("[Browser does not support Web Speech API — transcripts will be uploaded for server-side transcription]");
      return;
    }
    if(recognition) return;
    recognition = new SpeechRecognition();
    recognition.interimResults = false;
    recognition.continuous = true;
    recognition.lang = 'en-US';

    recognition.onstart = () => { console.log('Speech recognition started'); }
    recognition.onerror = (ev) => { console.warn('Speech recognition error', ev); }
    recognition.onend = () => {
      if(recorder && recorder.state === 'recording') {
        try { recognition.start(); } catch(e){ console.warn('restart recognition failed',e); }
      }
    };

    recognition.onresult = (evt) => {
      for(let i=evt.resultIndex; i<evt.results.length; ++i){
        if(evt.results[i].isFinal){
          const text = evt.results[i][0].transcript;
          // small cleaning: remove leading filler words repeated etc.
          appendTranscriptPiece(text);
        }
      }
    };

    try{
      recognition.start();
    }catch(e){
      console.warn('Recognition start failed', e);
    }
  }

  function stopSpeechRecognition(){
    if(recognition){
      try { recognition.onend = null; recognition.stop(); } catch(e){}
      recognition = null;
    }
  }

  // read query params meeting + owner + participant_email
  function getParams(){
    try{
      const qs = new URLSearchParams(location.search);
      return {
        meeting: qs.get('meeting') || qs.get('m') || location.href,
        owner: qs.get('owner') || qs.get('o') || undefined,
        participant_email: qs.get('participant_email') || undefined
      };
    }catch(e){
      return { meeting: location.href };
    }
  }

  // Upload JSON endpoint
  async function uploadRecording(){
    if(recordedChunks.length === 0 && !liveTranscript){
      alert('No audio or transcript recorded yet.');
      return;
    }
    uploadBtn.disabled = true;
    uploadStatus.textContent = 'Uploading...';
    notice.textContent = '';
    const blob = recordedChunks.length ? new Blob(recordedChunks, { type: 'audio/webm' }) : null;
    const params = getParams();

    // prefer JSON flow: { meeting, owner, participant_email, transcript }
    const payload = {
      meeting: params.meeting,
      owner: params.owner,
      participant_email: params.participant_email,
      transcript: liveTranscript || "",
      final: true
    };

    try{
      // Attempt JSON POST first
      const resp = await fetch(APP_BASE + '/upload-recording', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await resp.json().catch(()=>({}));
      if(!resp.ok){
        throw new Error(JSON.stringify(data) || resp.statusText);
      }
      uploadStatus.textContent = 'Upload successful.';
      notice.textContent = 'Upload successful.';
      // If server returned mom_link, show it
      if(data && data.mom_link){
        momLinkEl.href = data.mom_link;
        momLinkEl.textContent = data.mom_link;
        momLinkEl.style.display = 'inline';
        openMomBtn.style.display = 'inline-block';
        openMomBtn.onclick = ()=> window.open(data.mom_link, '_blank');
        notice.innerHTML += ' <br/>MoM available: <a href="'+data.mom_link+'" target="_blank">'+data.mom_link+'</a>';
      } else {
        // no mom_link yet — server may generate shortly
        notice.textContent = 'Upload succeeded — but no MoM link returned (server may generate shortly).';
      }
      alert('Upload successful.');
    }catch(err){
      console.error(err);
      uploadStatus.textContent = 'Upload failed';
      notice.textContent = 'Upload failed: ' + (err.message || err);
      alert('Upload failed: ' + (err.message || err));
    } finally {
      uploadBtn.disabled = false;
    }
  }

  // Auto-start attempt on page load
  async function autoStart(){
    try{
      await startRecording();
    }catch(e){
      console.log('Auto-start blocked:', e);
      updateStatus('Click Start Recording to enable mic');
      showWave('Auto-start blocked by browser — please click Start.');
      startBtn.disabled = false;
    }
  }

  // Hook up UI
  startBtn.addEventListener('click', async (e) => {
    startBtn.disabled = true;
    try {
      await startRecording();
    } catch(err) {
      startBtn.disabled = false;
      console.error(err);
    }
  });

  stopBtn.addEventListener('click', (e) => {
    stopRecording();
  });

  uploadBtn.addEventListener('click', (e) => {
    uploadRecording();
  });

  // Try auto-start after a tick
  setTimeout(autoStart, 700);

})();
</script>
</body>
</html>
