<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Confirm meeting — AI Scheduler</title>
<style>
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:18px;max-width:860px;margin:0 auto;color:#0f172a}
  h2{margin:0 0 12px}
  .note{color:#6b7280;margin-bottom:12px}
  .slots{display:flex;flex-direction:column;gap:12px}
  .slot{border:1px solid #eef2ff;padding:10px;border-radius:8px;background:#fff}
  .slot .human{font-weight:700}
  .controls{margin-top:14px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{width:100%;padding:8px;border-radius:8px;border:1px solid #e6e9ef}
  .row{display:flex;gap:8px}
  button{cursor:pointer;border-radius:8px;padding:8px 12px;border:0;font-weight:600}
  .btn-primary{background:linear-gradient(90deg,#4f46e5,#06b6d4);color:#fff}
  .btn-ghost{background:#fff;border:1px solid #e6e9ef;color:#0f172a}
  .muted{color:#6b7280;font-size:13px}
  .small{font-size:13px;color:#6b7280}
</style>
</head>
<body>
  <h2>Suggested slots</h2>
  <div class="note">Confirm a slot to create the event in your Microsoft calendar. If you haven't connected Microsoft, click <strong>Connect Microsoft</strong>.</div>

  <div id="main">
    <div id="loading" class="small">Loading suggestions…</div>

    <div id="slots" class="slots" style="display:none"></div>

    <div id="no-slots" style="display:none" class="muted">No suggestions were returned.</div>

    <div id="confirm-panel" style="display:none;margin-top:18px">
      <div style="margin-bottom:8px"><input id="subject" class="input" placeholder="Subject (optional) — e.g. Quick sync" /></div>
      <div style="margin-bottom:8px"><input id="attendees" class="input" placeholder="Attendees (comma separated emails) — optional" /></div>
      <div class="controls">
        <button id="createBtn" class="btn-primary">Create event</button>
        <button id="connectMsBtn" class="btn-ghost">Connect Microsoft</button>
        <div id="status" class="small muted"></div>
      </div>
    </div>
  </div>

<script>
/*
  teams_task.html behaviour:
   - Query params:
       prompt (required)
       user_key (recommended) — email/UPN used to look up ms token
       attendees (optional, comma separated)
       today_only (optional, "1" or "true")
   - Calls /suggest with prompt + user_key to retrieve final candidates (same as main UI)
   - Renders up to the returned suggestions (we handle either array or { slots: [...] } style)
   - Allows editing subject and attendees, and posts to /ms/graph/create_event with user_key
   - If MS is not connected (server returns 401/not_connected), shows Connect button which goes to /ms/auth/start?next=<current page>
*/

const Q = new URLSearchParams(location.search);
const PROMPT = Q.get('prompt') || '';
const USER_KEY = Q.get('user_key') || '';
const ATT_Q = Q.get('attendees') || '';
const TODAY_ONLY = Q.get('today_only') || '';
const API_BASE = location.origin.replace(/\/$/, '');

const slotsEl = document.getElementById('slots');
const loadingEl = document.getElementById('loading');
const noSlotsEl = document.getElementById('no-slots');
const confirmPanel = document.getElementById('confirm-panel');
const createBtn = document.getElementById('createBtn');
const connectMsBtn = document.getElementById('connectMsBtn');
const statusEl = document.getElementById('status');
const subjectInput = document.getElementById('subject');
const attendeesInput = document.getElementById('attendees');

let SUGGESTIONS = [];   // canonical array of { start, end, human, slot? ... }
let SELECTED_INDEX = null;

attendeesInput.value = ATT_Q.replace(/\+/g, ' ');

function showStatus(msg, isError=false){
  statusEl.textContent = msg || '';
  statusEl.style.color = isError ? '#b91c1c' : '#6b7280';
}

function fmtHuman(s){
  if(!s) return '';
  if(s.human) return s.human;
  if(s.slot && (s.slot.start || s.slot.end)) {
    return (s.slot.start || s.start) + ' → ' + (s.slot.end || s.end);
  }
  if(s.start && s.end) return s.start + ' → ' + s.end;
  return JSON.stringify(s).slice(0,150);
}

function canonicalizeList(resp){
  // resp may already be an array, or may be object with .slots, or parser result etc.
  if(!resp) return [];
  if(Array.isArray(resp)) return resp;
  if(resp.slots && Array.isArray(resp.slots)) return resp.slots;
  // sometimes server returns array-like object; attempt to extract keys
  if(resp.length && typeof resp.length === 'number') return Array.from(resp);
  return [];
}

async function fetchSuggestions(){
  if(!PROMPT){
    loadingEl.textContent = "No prompt provided.";
    return;
  }
  loadingEl.style.display = 'block';
  slotsEl.style.display = 'none';
  noSlotsEl.style.display = 'none';
  confirmPanel.style.display = 'none';
  showStatus('');

  try{
    // 1) Run parser first to detect explicit_time / requested_start
    let parserResp = null;
    try{
      const pResp = await fetch(API_BASE + '/nlp/suggest', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ prompt: PROMPT })
      });
      if(pResp.ok) parserResp = await pResp.json();
      else parserResp = null;
    }catch(e){
      // parser failing is non-fatal; we'll still call /suggest with prompt
      console.warn('parser error', e);
      parserResp = null;
    }

    // Build /suggest request body (force LOCAL_TZ so task UI uses same timezone as main UI)
    const body = {
      prompt: PROMPT,
      time_zone: 'Asia/Kolkata',            // keep same as server LOCAL_TZ
      today_only: (TODAY_ONLY === '1' || TODAY_ONLY === 'true'),
    };
    if(USER_KEY) body.user_key = USER_KEY;
    // prefer the attendees input field over query param if user edited it in UI
    if(attendeesInput.value) body.attendees = attendeesInput.value.split(',').map(s=>s.trim()).filter(Boolean);
    else if(ATT_Q) body.attendees = ATT_Q.split(',').map(s=>s.trim()).filter(Boolean);

    // 2) If parser says explicit_time, forward requested_start + explicit flag
    // This ensures /suggest tightens around requested_start (so you get the 2pm slot)
    if(parserResp && (parserResp.explicit_time || parserResp.requested_start || parserResp.window_start)){
      const req = parserResp.requested_start || parserResp.window_start || null;
      if(req){
        body.explicit_time = true;
        body.requested_start = req;
        // If parser returned a window_end, forward it too
        if(parserResp.requested_end) body.requested_end = parserResp.requested_end;
      }
    }

    // 3) Call /suggest (final producer)
// --- START: run parser and forward explicit_time/requested_start when present ---
try {
  const parserRespRaw = await fetch(API_BASE + '/suggest/with_parser', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt: PROMPT })
  });
  if (parserRespRaw.ok) {
    const parsed = await parserRespRaw.json();
    // parser may return requested_start, window_start, or explicit_time flag
    if (parsed && (parsed.explicit_time || parsed.requested_start || parsed.window_start)) {
      const req = parsed.requested_start || parsed.window_start || null;
      if (req) {
        body.explicit_time = true;
        body.requested_start = req;
        // ensure timezone present like main UI
        body.time_zone = 'Asia/Kolkata';
        // also forward requested_end if parser provided it
        if (parsed.requested_end) body.requested_end = parsed.requested_end;
      }
    }
  } else {
    console.warn('/nlp/suggest returned non-OK status', parserRespRaw.status);
  }
} catch (err) {
  console.warn('parser check failed (non-fatal):', err);
}
// --- END parser block ---


    const r = await fetch(API_BASE + '/suggest', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(body)
    });

    if(!r.ok){
      const txt = await r.text().catch(()=>'{no body}');
      throw new Error('Suggest failed: ' + r.status + ' ' + txt);
    }

    const json = await r.json();
    const arr = canonicalizeList(json);
    SUGGESTIONS = arr.map(x => {
      const start = (x.slot && x.slot.start) || x.start || (x.requested_start || null);
      const end   = (x.slot && x.slot.end)   || x.end   || null;
      const human = x.human || (x.explanation && x.explanation.readable) || fmtHuman(x);
      return Object.assign({}, x, { start, end, human });
    });

    if(SUGGESTIONS.length === 0){
      loadingEl.style.display = 'none';
      noSlotsEl.style.display = 'block';
      return;
    }

    renderSlots();
    loadingEl.style.display = 'none';
    slotsEl.style.display = 'block';
    confirmPanel.style.display = 'block';
    subjectInput.value = subjectInput.value || (PROMPT.length>0 ? (PROMPT.length<=120 ? PROMPT : PROMPT.slice(0,116)+'...') : 'Meeting');
    showStatus('');
  }catch(err){
    console.error(err);
    loadingEl.style.display = 'none';
    showStatus('Failed to fetch suggestions: ' + (err.message || err), true);
  }
}

function renderSlots(){
  slotsEl.innerHTML = '';
  SUGGESTIONS.forEach((s, idx) => {
    const el = document.createElement('div');
    el.className = 'slot';
    el.innerHTML = `
      <div class="human">${s.human || (s.start + ' → ' + s.end)}</div>
      <div class="small muted" style="margin-top:6px">${s.start || ''} → ${s.end || ''}</div>
      <div style="margin-top:8px">
        <button class="btn-ghost" data-idx="${idx}" style="margin-right:8px">Select</button>
        <button class="btn-ghost" data-idx-view="${idx}">Open raw</button>
      </div>
    `;
    slotsEl.appendChild(el);
  });

  // attach handlers
  slotsEl.querySelectorAll('button[data-idx]').forEach(b=>{
    b.onclick = (ev)=>{
      const idx = Number(ev.currentTarget.getAttribute('data-idx'));
      selectSlot(idx);
    };
  });
  slotsEl.querySelectorAll('button[data-idx-view]').forEach(b=>{
    b.onclick = (ev)=>{
      const idx = Number(ev.currentTarget.getAttribute('data-idx-view'));
      alert('Raw candidate JSON:\\n' + JSON.stringify(SUGGESTIONS[idx], null, 2));
    };
  });

  // select first by default
  if(SUGGESTIONS.length>0) selectSlot(0);
}

function selectSlot(idx){
  SELECTED_INDEX = idx;
  // visually mark (simple): scroll into view and highlight background briefly
  const children = Array.from(slotsEl.children);
  children.forEach((c,i)=> c.style.boxShadow = (i===idx) ? '0 6px 20px rgba(79,70,229,0.08)' : 'none');
  showStatus('Selected slot: ' + (SUGGESTIONS[idx].human || (SUGGESTIONS[idx].start + ' → ' + SUGGESTIONS[idx].end)));
}

function openConnectMs(){
  // redirect user to ms auth with next back to current page (preserve prompt + user_key)
  const next = encodeURIComponent(location.pathname + location.search);
  window.location.href = API_BASE + '/ms/auth/start?next=' + next;
}

connectMsBtn.addEventListener('click', openConnectMs);

createBtn.addEventListener('click', async ()=>{
  showStatus('');
  if(SELECTED_INDEX === null){ showStatus('Please select a slot first', true); return; }
  const sel = SUGGESTIONS[SELECTED_INDEX];
  if(!sel || !sel.start || !sel.end){ showStatus('Selected slot is missing start/end', true); return; }

  const subject = (subjectInput.value || 'Meeting scheduled via AI').trim();
  const attendees = attendeesInput.value ? attendeesInput.value.split(',').map(s=>s.trim()).filter(Boolean) : [];
  const payload = {
    user_key: (USER_KEY || ''), // server will error if missing, so UI should collect
    start: sel.start,
    end: sel.end,
    subject,
    attendees,
    body: `Scheduled from prompt: ${PROMPT}`
  };

  try{
    showStatus('Creating event...');
    createBtn.disabled = true;
    const r = await fetch(API_BASE + '/ms/graph/create_event', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    const data = await r.json().catch(()=>null);
    if(r.ok){
      showStatus('Event created successfully.', false);
      // show join link if present
      const link = (data && (data.onlineMeeting && data.onlineMeeting.joinUrl || data.webLink || data.htmlLink)) || '';
      if(link){
        const msg = 'Event created. Join link:\\n' + link;
        alert(msg);
      } else {
        alert('Event created successfully.');
      }
      // attempt to notify parent (Teams) to close Task Module if iframe parent supports postMessage
      try{ parent.postMessage({ action: 'close', result: data || {} }, '*'); }catch(e){}
    } else {
      // server returned non-200: show message and give connect option if not_connected
      if(data && data.error === 'not_connected'){
        showStatus('Microsoft account not connected for this user. Click Connect Microsoft to sign in.', true);
      } else if(data && data.error === 'missing_user_key'){
        showStatus('Missing user_key — include user_key in the Task Module url query (e.g., ?user_key=you@example.com).', true);
      } else {
        showStatus('Create failed: ' + (JSON.stringify(data) || 'unknown'), true);
      }
      console.error('create error', data);
    }
  }catch(e){
    console.error(e);
    showStatus('Unexpected error: ' + (e.message || e), true);
  } finally {
    createBtn.disabled = false;
  }
});

// bootstrap
fetchSuggestions();
</script>
</body>
</html>
